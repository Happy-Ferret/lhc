{-# LANGUAGE ViewPatterns #-}
module GhcDriver (
  compileHsToCoreFiles -- :: [String] -> [String] -> [String] -> IO [String]
, compileCFilesWithGhc -- :: [String] -> String -> [String] -> IO ()
) where

import Paths_lhc
import qualified Data.Version as Version
import System.Info
import System.Directory


import System.IO
import System.Environment
import System.Exit
import System.FilePath
import Control.Monad
import Data.List
import Data.Maybe

import Data.Word (Word)
import Foreign.Storable (sizeOf)
import System.Cmd

import Data.List ( isPrefixOf, nub )
import Data.List.Split ( sepBy )


compileCFilesWithGhc :: [String] -> String -> [String] -> IO ()
compileCFilesWithGhc compileOpts outfile sourceFiles
    = do libdir <- getLibdir
         -- generate the external core files
         let wordSize = sizeOf (undefined :: Word)
             compileCmd = unwords ([ "ghc", unwords compileOpts
                                   , "-B"++libdir,"-no-user-package-conf","-D__LHC__"
                                   , "-DWORD_SIZE="++show wordSize
                                   , "-DWORD_SIZE_IN_BITS="++show (wordSize*8)
                                   , unwords sourceFiles, "-o", outfile ])
         -- putStrLn $ "running '" ++ compileCmd ++ "'"
         system compileCmd
         return ()

compileHsToCoreFiles :: Bool -> Bool -> [String] -> [String] -> [String] -> IO [String]
compileHsToCoreFiles buildingLib noLink compileOpts depgenOpts sourceFiles 
    = do libdir <- getLibdir
         -- generate the external core files
         let wordSize = sizeOf (undefined :: Word)
             compileCmd = unwords ([ "ghc", unwords compileOpts
                                   , "-B"++libdir,"-no-user-package-conf","-D__LHC__"
                                   , "-DWORD_SIZE="++show wordSize
                                   , "-DWORD_SIZE_IN_BITS="++show (wordSize*8)
                                   , unwords sourceFiles ])
         -- putStrLn $ "running '" ++ compileCmd ++ "'"
         exitCode <- system compileCmd
         unless (exitCode == ExitSuccess) $ exitWith exitCode
         
         let noSourceFiles = not (any ((`elem` [".hs",".lhs"]) . takeExtension) sourceFiles)

         if (noLink || buildingLib || noSourceFiles) then  -- only generate the makefile if we're building an executable
             return []
          else do
             -- generate the makefile
             let makefileOut = ".lhc" <.> "dep-makefile"
                 rmBadOpts opts = foldr delete opts [ "--make"
                                                    , "--make" ] -- once for us, once for 'cabal install'
                 -- TODO: make this not utterly terrible
                 depgenCmd = unwords . rmBadOpts . words . unwords $
                              ["ghc", "-M"
                              , "-B"++libdir,"-no-user-package-conf","-D__LHC__"
                              , "-DWORD_SIZE="++show wordSize
                              , "-DWORD_SIZE_IN_BITS="++show (wordSize*8)
                              , "-dep-makefile", makefileOut
                              , unwords depgenOpts, unwords sourceFiles ] 

             -- putStrLn $ "running '" ++ depgenCmd ++ "'"
             system depgenCmd
             -- now parse it
             (coreFiles, _, _) <- parseMakefile makefileOut
             -- delete temporary files
             removeFile makefileOut
             return $ reverse coreFiles

-- | Parses a makefile generated by \'ghc -M\'.
-- After parsing, it gets the location of all the object files from the dependency info.
-- It returns a tuple consisting of the list of external core files, the list of object 
-- files, and the list of hi files generated by GHC
parseMakefile :: FilePath -> IO ([FilePath], [FilePath], [FilePath])
parseMakefile makefile 
    = do contents <- lines `liftM` (readFile makefile)
         return $ unzip3 $ nub $ foldr parse [] contents
  where parse   (isComment -> True)  seed = seed
        parse l@(isComment -> False) seed = 
            let obj = head $ sepBy " : " l -- parse the 'Foo/Bar/Baz.o ' part
                hcr = replaceExtension obj "hcr"
                hi  = replaceExtension obj "hi"
                -- remove 'dist' prefix that cabal puts on, because external core ignores e.g. -outdir
                r   = (if ("dist/build/" `isPrefixOf` hcr) then (drop 11 hcr) else hcr, obj, hi)
            in (r:seed)
        isComment = isPrefixOf "#"
        trim = reverse . dropWhile (==' ') . reverse . dropWhile (==' ')
 
-- | returns the LHC library directory path
getLibdir :: IO FilePath
getLibdir = do appdir <- getAppUserDataDirectory "lhc"
               let targetARCH = arch
                   targetOS   = os
               let subdir = targetARCH ++ '-':targetOS ++ '-':Version.showVersion version
               return (appdir </> subdir)
